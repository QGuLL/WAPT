Index: common/JclAnsiStrings.pas
===================================================================
--- common/JclAnsiStrings.pas	(revision 3860)
+++ common/JclAnsiStrings.pas	(working copy)
@@ -506,8 +506,8 @@
 
 function ArrayOf(List: TJclAnsiStrings): TDynStringArray; overload;
 
-function AnsiCompareNaturalStr(const S1, S2: AnsiString): SizeInt;
-function AnsiCompareNaturalText(const S1, S2: AnsiString): SizeInt;
+function AnsiCompareNaturalStr(const S1, S2: AnsiString): SizeInt; overload;
+function AnsiCompareNaturalText(const S1, S2: AnsiString): SizeInt;overload;
 
 // internal structures published to make function inlining working
 const
Index: common/JclDateTime.pas
===================================================================
--- common/JclDateTime.pas	(revision 3860)
+++ common/JclDateTime.pas	(working copy)
@@ -87,7 +87,7 @@
 
 { Encode / Decode functions }
 
-function EncodeDate(const Year: Integer; Month, Day: Word): TDateTime;
+function EncodeDate(const Year: Integer; Month, Day: Word): TDateTime; overload;
 procedure DecodeDate(Date: TDateTime; out Year, Month, Day: Word); overload;
 procedure DecodeDate(Date: TDateTime; out Year: Integer; out Month, Day: Word); overload;
 procedure DecodeDate(Date: TDateTime; out Year, Month, Day: Integer); overload;
Index: common/JclStrings.pas
===================================================================
--- common/JclStrings.pas	(revision 3860)
+++ common/JclStrings.pas	(working copy)
@@ -592,8 +592,8 @@
 {$ENDIF SUPPORTS_UNICODE_STRING}
 
 // natural comparison functions
-function CompareNaturalStr(const S1, S2: string): SizeInt;
-function CompareNaturalText(const S1, S2: string): SizeInt;
+function CompareNaturalStr(const S1, S2: string): SizeInt; overload;
+function CompareNaturalText(const S1, S2: string): SizeInt; overload;
 
 {$IFNDEF UNICODE_RTL_DATABASE}
 // internal structures published to make function inlining working
Index: common/JclSysUtils.pas
===================================================================
--- common/JclSysUtils.pas	(revision 3860)
+++ common/JclSysUtils.pas	(working copy)
@@ -419,7 +419,7 @@
   public
     procedure AfterConstruction; override;
     { IInterface }
-    function QueryInterface(const IID: TGUID; out Obj): HRESULT; virtual; stdcall;
+    function QueryInterface(constref IID: TGUID; out Obj): HRESULT; virtual; stdcall;
     function _AddRef: Integer; stdcall;
     function _Release: Integer; stdcall;
   end;
@@ -644,7 +644,7 @@
     constructor Create;
     destructor Destroy; override;
     { IInterface }
-    function QueryInterface(const IID: TGUID; out Obj): HRESULT; stdcall;
+    function QueryInterface(constref IID: TGUID; out Obj): HRESULT; stdcall;
     function _AddRef: Integer; stdcall;
     function _Release: Integer; stdcall;
   end;
@@ -2217,8 +2217,8 @@
     GetOwner.GetInterface(IInterface, FOwnerInterface);
 end;
 
-function TJclInterfacedPersistent.QueryInterface(const IID: TGUID;
-  out Obj): HRESULT;
+function TJclInterfacedPersistent.QueryInterface(constref IID: TGUID;
+  out Obj): HRESULT; stdcall;
 begin
   if GetInterface(IID, Obj) then
     Result := S_OK
@@ -2855,7 +2855,7 @@
       end;
       InternalAbort := False;
       if AbortPtr <> nil then
-        AbortPtr^ := False
+        AbortPtr^ := Byte(False)
       else
         AbortPtr := @InternalAbort;
       // init the array of events to wait for
@@ -2897,7 +2897,7 @@
         InternalExecuteReadPipe(ErrorPipeInfo, ErrorOverlapped);
       end;
       // event based loop
-      while not AbortPtr^ do
+      while not boolean(AbortPtr^) do
       begin
         Index := WaitAlertableForMultipleObjects(WaitEvents, False, INFINITE);
         if Index = WAIT_OBJECT_0 then
@@ -2927,7 +2927,7 @@
         if ((Index = (WAIT_OBJECT_0 + 2)) and MergeError) or
            ((Index = (WAIT_OBJECT_0 + 3)) and not MergeError) then
           // event on abort
-          AbortPtr^ := True
+          AbortPtr^ := Byte(True)
         else
           {$IFDEF DELPHI11_UP}
           RaiseLastOSError(Index);
@@ -2935,7 +2935,7 @@
           RaiseLastOSError;
           {$ENDIF DELPHI11_UP}
       end;
-      if AbortPtr^ then
+      if boolean(AbortPtr^) then
         TerminateProcess(ProcessEvent.Handle, Cardinal(ABORT_EXIT_CODE));
       if (ProcessEvent.WaitForever = wrSignaled) and not GetExitCodeProcess(ProcessEvent.Handle, Result) then
         Result := $FFFFFFFF;
@@ -3619,7 +3619,7 @@
   Result := 0;
 end;
 
-function TJclIntfCriticalSection.QueryInterface(const IID: TGUID; out Obj): HRESULT;
+function TJclIntfCriticalSection.QueryInterface(constref IID: TGUID; out Obj): HRESULT;
 begin
   if GetInterface(IID, Obj) then
     Result := S_OK
Index: common/JclUnicode.pas
===================================================================
--- common/JclUnicode.pas	(revision 3860)
+++ common/JclUnicode.pas	(working copy)
@@ -2769,7 +2769,7 @@
   ClearResults;
   Run := Text;
   RunLen := TextLen;
-  Start := 0;
+{  Start := 0;
   Stop := 0;
   // repeat to find all occurences of the pattern
   while Find(Run, RunLen, Start, Stop) do
@@ -2781,6 +2781,8 @@
     Dec(RunLen, Stop);
   end;
   Result := Count > 0;
+}
+raise Exception.create('non implemented');
 end;
 
 function TUTBMSearch.FindFirst(const Text: WideString; var Start, Stop: SizeInt): Boolean;
@@ -4741,7 +4743,7 @@
   Run := Text;
   RunLen := TextLen;
   // repeat to find all occurences of the pattern
-  Start := 0;
+{  Start := 0;
   Stop := 0;
   while ExecuteURE(0, Run, RunLen, Start, Stop) do
   begin
@@ -4752,6 +4754,7 @@
     Dec(RunLen, Stop);
   end;
   Result := FResults.Count > 0;
+  }
 end;
 
 function TURESearch.FindFirst(const Text: WideString; var Start, Stop: SizeInt): Boolean;
Index: windows/JclWin32.pas
===================================================================
--- windows/JclWin32.pas	(revision 3860)
+++ windows/JclWin32.pas	(working copy)
@@ -7242,7 +7242,7 @@
   PIDMSI_COPYRIGHT   = $0000000B; // VT_LPWSTR
   {$EXTERNALSYM PIDMSI_COPYRIGHT}
 
-function PropVariantClear(var Prop: TPropVariant): HResult; stdcall;
+//function PropVariantClear(var Prop: TPropVariant): HResult; stdcall;
 {$EXTERNALSYM PropVariantClear}
 
 
@@ -8860,7 +8860,7 @@
 end;
 
 
-type
+{type
   TPropVariantClear = function (var Prop: TPropVariant): HResult; stdcall;
 
 var
@@ -8871,8 +8871,8 @@
   GetProcedureAddress(Pointer(@_PropVariantClear), Ole32Lib, 'PropVariantClear');
   Result := _PropVariantClear(Prop);
 end;
+  }
 
-
 type
   TLsaOpenPolicy = function (SystemName: PLSA_UNICODE_STRING;
     var ObjectAttributes: LSA_OBJECT_ATTRIBUTES; DesiredAccess: ACCESS_MASK;
